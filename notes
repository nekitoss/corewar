работа с минусовыми значениями при IDX_MOD через signed shot int
каретка передвинется на размер параметров, зашифрованных после опкода
непрямой адрес - сдвиг каретки относительно текущего PC
прямой (direct) - число (после процента)
керри изменяется если в регистре вышел ноль
джамп работает только если керри=1
новый процесс (форк) кладется на верх стека
новый процесс наследует все от отца, кроме РС, РС пересчитывается на джамп (IDX mod attention)
количество лайвов суммируется и проверяется каждые CYCLE_TO_DIE, если оно больше NBR_LIVE тогда уменьшается на CYCLE_DELTA
если лайвов меньше заданного, но прошло CYCLE_TO_DIE в количестве MAX_CHECKS раз, все равно уменьшить
система First In Last Out -  если у всех процессов по одному лайву, выиграет тот кто сказал лайв последним - тоесть тот, который зашел как первый процесс.
сделать дамп памяти - в хексе, по 32 октета (байта) в строке (по пдф) в шестндцатиричном формате
процессы запослняются согласно нумерации игроков, если повторяются или больше номера игрока - ошибка
в первом регистре - номер игрока, размером REG_SIZE=4=int
номера игроков идут -1 -2 -3 -4
сумма лайвов, которая проверяется NBR_LIVE - для лайвов с любым параметром, даже если лайв сказан за не существующих игроков.
для кадого игрока - ласт лайв играет роль - последний сказавший = виннер
Aff: ?
aff при параметре -а
статистику соотношения предыдущего раунда и текущего раунда
скорость циклов
добавить к виртуалке: состояние в регистрах и керри.
коректность размера данных сравнить по аналогу таблицы op.c, 
состояние кодирующих пар байт не использованных переменных (больше кол-ва аргументов) не влияет на работу программы
если кодирующие байты неверные, считается размер предположительного количества данных, но учитываются только байты, которые должны были быть закодированы и каретка перепрыгивет
если размера директа не существует, он считается как бОльший = 4 байта
каретка при наличии кодирующего байта, равного нулю, перепрыгнет на позицию после него
каретку при движении %MEM_SIZE - тогда автоматом -2 выдаст MEM_SIZE-2=4094, но если перед тем сделать %IDX_MOD - тогда все поломается
T_IND = 4 !=3 (задекларирован в op.c как 4)
Если ни один не сказал лайв, или все сказали в один и тот же цикл - выиграет последний. Если один сказал лайв и помер, а другие не сказали - выиграл он.
если число больше mem_size но должно быть поделено на IDX_MOD - тогда можно утратить число равное -2
лайвы общие считаются при любом параметре лайва. тоесть за игрока 50 тоже считается в общее, чтобы сравнить с NBR_LIVE
процесс надо убить(удалить из стека), если он ни разу не наступил на лайв за CYCLES_TO_DIE
+-1 цикл при выполнении; перед или после инкрементить циклы; перед или после процессов проверять смертоциклы


// t_my_op				op_tab[17] =
// {
// 	{"live", 	1, {T_DIR},													1,	10,		"alive",								0, 0, void (*func)(t_core *ls, t_proc *proc)},
// 	{"ld", 		2, {T_DIR | T_IND, T_REG},									2,	5,		"load",									1, 0, void (*func)(t_core *ls, t_proc *proc)},
// 	{"st", 		2, {T_REG, T_IND | T_REG},									3,	5,		"store",								1, 0, void (*func)(t_core *ls, t_proc *proc)},
// 	{"add", 	3, {T_REG, T_REG, T_REG},									4,	10,		"addition",								1, 0, void (*func)(t_core *ls, t_proc *proc)},
// 	{"sub", 	3, {T_REG, T_REG, T_REG},									5,	10,		"soustraction",							1, 0, void (*func)(t_core *ls, t_proc *proc)},
// 	{"and", 	3, {T_REG | T_DIR | T_IND, T_REG | T_IND | T_DIR, T_REG},	6,	6,		"et (and  r1, r2, r3   r1&r2 -> r3",	1, 0, void (*func)(t_core *ls, t_proc *proc)},
// 	{"or", 		3, {T_REG | T_IND | T_DIR, T_REG | T_IND | T_DIR, T_REG},	7,	6,		"ou  (or   r1, r2, r3   r1 | r2 -> r3",	1, 0, void (*func)(t_core *ls, t_proc *proc)},
// 	{"xor", 	3, {T_REG | T_IND | T_DIR, T_REG | T_IND | T_DIR, T_REG},	8,	6,		"ou (xor  r1, r2, r3   r1^r2 -> r3",	1, 0, void (*func)(t_core *ls, t_proc *proc)},
// 	{"zjmp", 	1, {T_DIR},													9,	20,		"jump if zero",							0, 1, void (*func)(t_core *ls, t_proc *proc)},
// 	{"ldi", 	3, {T_REG | T_DIR | T_IND, T_DIR | T_REG, T_REG},			10,	25,		"load index",							1, 1, void (*func)(t_core *ls, t_proc *proc)},
// 	{"sti", 	3, {T_REG, T_REG | T_DIR | T_IND, T_DIR | T_REG},			11,	25,		"store index",							1, 1, void (*func)(t_core *ls, t_proc *proc)},
// 	{"fork", 	1, {T_DIR},													12,	800,	"fork",									0, 1, void (*func)(t_core *ls, t_proc *proc)},
// 	{"lld", 	2, {T_DIR | T_IND, T_REG},									13,	10,		"long load",							1, 0, void (*func)(t_core *ls, t_proc *proc)},
// 	{"lldi", 	3, {T_REG | T_DIR | T_IND, T_DIR | T_REG, T_REG},			14,	50,		"long load index",						1, 1, void (*func)(t_core *ls, t_proc *proc)},
// 	{"lfork", 	1, {T_DIR},													15,	1000,	"long fork",							0, 1, void (*func)(t_core *ls, t_proc *proc)},
// 	{"aff", 	1, {T_REG},													16,	2,		"aff",									1, 0, void (*func)(t_core *ls, t_proc *proc)},
// };